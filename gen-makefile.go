package main

//
// gen-makefile.go -- Generate a makefile for .md files that uses "m4" to process the files into a single .md file
// (C) Philip Schlump, 2013.
//
// ToDo:
//	1. add a -p Path 			Path for looking for templates
//	2. add a -t TemplateName	Name of the template file
//	3. add a -d "pattern"		To search files for pattern and process to find dependencies m4_include(xxx) is a depenedency
//								create a .Dependencies array in the data [] string
//
// Example with Range: http://jan.newmarch.name/go/template/chapter-template.html 
//


import (
	"fmt"
    "./go-flags"
    "text/template"
    "io/ioutil"
    "os"
	"path/filepath"
)

type  TemplateData struct {
	Files		[]string
	DestDir		string
	// DependsOn	[]string
}

// var TMPL_DIR = "../../tmpl/"
var TMPL_DIR = "/home/pschlump/www/sketchground/pjs/99-static/tmpl/"
var WEB_DIR = "/home/pschlump/www/sketchground/pjs/99-static/_site/"

var  Verbose []bool
var  gArgs [] string;

func ParseCmdLineArgs() {
	var opts struct {
		Verbose []bool `short:"v" long:"verbose" description:"Show verbose debug information"`
	}

	args, err := flags.ParseArgs(&opts, os.Args)

	if err != nil {
			panic(err)
			os.Exit(1)
	}

	Verbose = opts.Verbose
	gArgs = args
}


// Exists reports whether the named file or directory exists.
func Exists(name string) bool {
    if _, err := os.Stat(name); err != nil {
		if os.IsNotExist(err) {
			return false
		   }
		}
	return true
}


func getRawFile(path string) []byte {
	// path = strings.Replace(path, "../", "", -1)
	file, err := ioutil.ReadFile(path)
	if err != nil {
		return nil
	}
	return file
}

//	Makefile_res_tmpl = GetTemplate ( "./tmpl/Makefile_res.tmpl" )
func GetTemplate ( fn string ) []byte {
	var path_fn = TMPL_DIR + fn
	return getRawFile ( path_fn )
}

func main() {

	// -------------------------------------------------------------------------------------------------------------------
	// Part 1 - get the Arguments from the Command Line
	ParseCmdLineArgs()

	// -------------------------------------------------------------------------------------------------------------------
	// Part 3 - A - Process Dirs

	templateData := TemplateData {}
	templateData.Files = gArgs[1:]

	dir, _ := os.Getwd()
	templateData.DestDir = WEB_DIR + filepath.Base(dir)

	// fmt.Printf ( "gArgs = %v\n", gArgs )
	// fmt.Printf ( "gArgs[1:] = %v\n", gArgs[1:] )
	// fmt.Printf ( "templateData = %v\n", templateData )

	var Makefile_res_tmpl  []byte
	Makefile_res_tmpl = GetTemplate ( "Makefile_res.tmpl" )				// Use "TMPL_PATH" to find the template
	t, err := template.New("makefile_res").Parse(string(Makefile_res_tmpl))
	if err != nil { panic(err) }
	// fmt.Printf ( "tmpl = %s\n", Makefile_res_tmpl )

	if ! Exists( "./Makefile" ) {

		fo, err := os.Create("Makefile")				// xyzzy - make this into a func.
		if err != nil { panic(err) }
		defer func() {			// close fo on exit and check for its returned error
			if err := fo.Close(); err != nil {
				panic(err)
			}
		}()

		fmt.Fprintf ( fo, "\n# Generated by gen-makefile.go - do not modify\n" );

		err = t.ExecuteTemplate(fo, "makefile_res", templateData)
		if err != nil { panic(err) }

	}

}



